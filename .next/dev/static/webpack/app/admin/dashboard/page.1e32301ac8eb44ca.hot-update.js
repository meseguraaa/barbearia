"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/dashboard/page", {
  /***/ "(app-pages-browser)/./src/components/appointment-form/constants-and-utils.ts":
    /*!****************************************************************!*\
  !*** ./src/components/appointment-form/constants-and-utils.ts ***!
  \****************************************************************/
    /***/ (module, __webpack_exports__, __webpack_require__) => {
      eval(
        __webpack_require__.ts(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SERVICE_OPTIONS: () => (/* binding */ SERVICE_OPTIONS),\n/* harmony export */   TIME_OPTIONS: () => (/* binding */ TIME_OPTIONS),\n/* harmony export */   getAvailableTimes: () => (/* binding */ getAvailableTimes),\n/* harmony export */   getServiceDuration: () => (/* binding */ getServiceDuration)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/isSameDay.js");\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/getHours.js");\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/getMinutes.js");\n\nconst SERVICE_OPTIONS = [\n    "Barba - R$80,00",\n    "Barba & Cabelo - R$120,00",\n    "Cabelo na tesoura - R$100,00",\n    "Cabelo na mÃ¡quina"\n];\n// â± DuraÃ§Ã£o de cada serviÃ§o (em minutos)\nconst SERVICE_DURATION_MAP = {\n    "Barba": 30,\n    "Barba & Cabelo": 60,\n    "Cabelo na tesoura": 60,\n    "Cabelo na mÃ¡quina": 30\n};\n/**\n * FunÃ§Ã£o robusta para descobrir a duraÃ§Ã£o do serviÃ§o\n * a partir da descriÃ§Ã£o salva no banco.\n */ const getServiceDuration = (description)=>{\n    if (!description) return 30;\n    const normalized = description.trim().toLowerCase();\n    if (normalized.startsWith("barba & cabelo")) return 60;\n    if (normalized.startsWith("cabelo na tesoura")) return 60;\n    if (normalized.startsWith("barba - r$80")) return 30;\n    if (normalized.startsWith("cabelo na mÃ¡quina")) return 30;\n    const key = description;\n    if (key in SERVICE_DURATION_MAP) {\n        return SERVICE_DURATION_MAP[key];\n    }\n    return 30;\n};\nconst generateTimeOptions = ()=>{\n    const times = [];\n    for(let hour = 9; hour <= 21; hour++){\n        for(let minute = 0; minute < 60; minute += 30){\n            if (hour === 21 && minute > 0) break;\n            const timeString = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`;\n            times.push(timeString);\n        }\n    }\n    return times;\n};\nconst TIME_OPTIONS = generateTimeOptions();\n// ðŸ” Calcula horÃ¡rios disponÃ­veis considerando:\n// - data selecionada\n// - serviÃ§o selecionado (duraÃ§Ã£o)\n// - agendamentos existentes (sem sobrepor)\n// - horÃ¡rios passados no dia de hoje\nconst getAvailableTimes = (params)=>{\n    const { date, service, appointments, currentAppointmentId } = params;\n    if (!date || !service) return [];\n    const now = new Date();\n    const selectedDuration = getServiceDuration(service);\n    let baseTimes = [\n        ...TIME_OPTIONS\n    ];\n    // Se for hoje, remove horÃ¡rios que jÃ¡ passaram\n    if ((0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(date, now)) {\n        const currentMinutes = (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__.getHours)(now) * 60 + (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.getMinutes)(now);\n        baseTimes = baseTimes.filter((time)=>{\n            const [hourStr, minuteStr] = time.split(":");\n            const hour = Number(hourStr);\n            const minute = Number(minuteStr);\n            const timeMinutes = hour * 60 + minute;\n            return timeMinutes > currentMinutes;\n        });\n    }\n    // Filtra agendamentos sÃ³ desse dia (independente do barbeiro)\n    const dayAppointments = appointments.filter((appt)=>(0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(new Date(appt.scheduleAt), date));\n    // Remove horÃ¡rios que colidem com qualquer agendamento existente\n    const availableTimes = baseTimes.filter((time)=>{\n        const [hourStr, minuteStr] = time.split(":");\n        const hour = Number(hourStr);\n        const minute = Number(minuteStr);\n        const candidateStart = hour * 60 + minute;\n        const candidateEnd = candidateStart + selectedDuration;\n        for (const appt of dayAppointments){\n            if (currentAppointmentId && appt.id === currentAppointmentId) continue;\n            const apptDate = new Date(appt.scheduleAt);\n            const apptStart = (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__.getHours)(apptDate) * 60 + (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.getMinutes)(apptDate);\n            const apptDuration = getServiceDuration(appt.description);\n            const apptEnd = apptStart + apptDuration;\n            const overlap = candidateStart < apptEnd && apptStart < candidateEnd;\n            if (overlap) return false;\n        }\n        return true;\n    });\n    return availableTimes;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2FwcG9pbnRtZW50LWZvcm0vY29uc3RhbnRzLWFuZC11dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJEO0FBR3BELE1BQU1HLGtCQUFrQjtJQUM3QjtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQVU7QUFJWCx5Q0FBeUM7QUFDekMsTUFBTUMsdUJBQXNEO0lBQzFELFNBQVM7SUFDVCxrQkFBa0I7SUFDbEIscUJBQXFCO0lBQ3JCLHFCQUFxQjtBQUN2QjtBQUVBOzs7Q0FHQyxHQUNNLE1BQU1DLHFCQUFxQixDQUFDQztJQUNqQyxJQUFJLENBQUNBLGFBQWEsT0FBTztJQUV6QixNQUFNQyxhQUFhRCxZQUFZRSxJQUFJLEdBQUdDLFdBQVc7SUFFakQsSUFBSUYsV0FBV0csVUFBVSxDQUFDLG1CQUFtQixPQUFPO0lBQ3BELElBQUlILFdBQVdHLFVBQVUsQ0FBQyxzQkFBc0IsT0FBTztJQUN2RCxJQUFJSCxXQUFXRyxVQUFVLENBQUMsaUJBQWlCLE9BQU87SUFDbEQsSUFBSUgsV0FBV0csVUFBVSxDQUFDLHNCQUFzQixPQUFPO0lBRXZELE1BQU1DLE1BQU1MO0lBQ1osSUFBSUssT0FBT1Asc0JBQXNCO1FBQy9CLE9BQU9BLG9CQUFvQixDQUFDTyxJQUFJO0lBQ2xDO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFRixNQUFNQyxzQkFBc0I7SUFDMUIsTUFBTUMsUUFBa0IsRUFBRTtJQUUxQixJQUFLLElBQUlDLE9BQU8sR0FBR0EsUUFBUSxJQUFJQSxPQUFRO1FBQ3JDLElBQUssSUFBSUMsU0FBUyxHQUFHQSxTQUFTLElBQUlBLFVBQVUsR0FBSTtZQUM5QyxJQUFJRCxTQUFTLE1BQU1DLFNBQVMsR0FBRztZQUMvQixNQUFNQyxhQUFhLEdBQUdGLEtBQ25CRyxRQUFRLEdBQ1JDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFSCxPQUFPRSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHLE1BQU07WUFDM0RMLE1BQU1NLElBQUksQ0FBQ0g7UUFDYjtJQUNGO0lBRUEsT0FBT0g7QUFDVDtBQUVPLE1BQU1PLGVBQWVSLHNCQUFzQjtBQUVsRCxnREFBZ0Q7QUFDaEQscUJBQXFCO0FBQ3JCLGtDQUFrQztBQUNsQywyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQzlCLE1BQU1TLG9CQUFvQixDQUFDQztJQU1oQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdKO0lBRTlELElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLE9BQU8sRUFBRTtJQUVoQyxNQUFNRyxNQUFNLElBQUlDO0lBRWhCLE1BQU1DLG1CQUFtQnhCLG1CQUFtQm1CO0lBRTVDLElBQUlNLFlBQVk7V0FBSVY7S0FBYTtJQUVqQywrQ0FBK0M7SUFDL0MsSUFBSWxCLHdHQUFTQSxDQUFDcUIsTUFBTUksTUFBTTtRQUN4QixNQUFNSSxpQkFBaUIvQix1R0FBUUEsQ0FBQzJCLE9BQU8sS0FBSzFCLHlHQUFVQSxDQUFDMEI7UUFFdkRHLFlBQVlBLFVBQVVFLE1BQU0sQ0FBQyxDQUFDQztZQUM1QixNQUFNLENBQUNDLFNBQVNDLFVBQVUsR0FBR0YsS0FBS0csS0FBSyxDQUFDO1lBQ3hDLE1BQU10QixPQUFPdUIsT0FBT0g7WUFDcEIsTUFBTW5CLFNBQVNzQixPQUFPRjtZQUN0QixNQUFNRyxjQUFjeEIsT0FBTyxLQUFLQztZQUVoQyxPQUFPdUIsY0FBY1A7UUFDdkI7SUFDRjtJQUVBLDhEQUE4RDtJQUM5RCxNQUFNUSxrQkFBa0JkLGFBQWFPLE1BQU0sQ0FBQyxDQUFDUSxPQUMzQ3RDLHdHQUFTQSxDQUFDLElBQUkwQixLQUFLWSxLQUFLQyxVQUFVLEdBQUdsQjtJQUd2QyxpRUFBaUU7SUFDakUsTUFBTW1CLGlCQUFpQlosVUFBVUUsTUFBTSxDQUFDLENBQUNDO1FBQ3ZDLE1BQU0sQ0FBQ0MsU0FBU0MsVUFBVSxHQUFHRixLQUFLRyxLQUFLLENBQUM7UUFDeEMsTUFBTXRCLE9BQU91QixPQUFPSDtRQUNwQixNQUFNbkIsU0FBU3NCLE9BQU9GO1FBQ3RCLE1BQU1RLGlCQUFpQjdCLE9BQU8sS0FBS0M7UUFDbkMsTUFBTTZCLGVBQWVELGlCQUFpQmQ7UUFFdEMsS0FBSyxNQUFNVyxRQUFRRCxnQkFBaUI7WUFDbEMsSUFBSWIsd0JBQXdCYyxLQUFLSyxFQUFFLEtBQUtuQixzQkFBc0I7WUFFOUQsTUFBTW9CLFdBQVcsSUFBSWxCLEtBQUtZLEtBQUtDLFVBQVU7WUFDekMsTUFBTU0sWUFBWS9DLHVHQUFRQSxDQUFDOEMsWUFBWSxLQUFLN0MseUdBQVVBLENBQUM2QztZQUN2RCxNQUFNRSxlQUFlM0MsbUJBQW1CbUMsS0FBS2xDLFdBQVc7WUFDeEQsTUFBTTJDLFVBQVVGLFlBQVlDO1lBRTVCLE1BQU1FLFVBQVVQLGlCQUFpQk0sV0FBV0YsWUFBWUg7WUFFeEQsSUFBSU0sU0FBUyxPQUFPO1FBQ3RCO1FBRUEsT0FBTztJQUNUO0lBRUEsT0FBT1I7QUFDVCxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYnJ1bm9sZWFsL0RvY3VtZW50cy9DdXJzb3MvTkVYVEpTL2JhcmJlYXJpYS9zcmMvY29tcG9uZW50cy9hcHBvaW50bWVudC1mb3JtL2NvbnN0YW50cy1hbmQtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SG91cnMsIGdldE1pbnV0ZXMsIGlzU2FtZURheSB9IGZyb20gXCJkYXRlLWZuc1wiO1xuaW1wb3J0IHsgQXBwb2ludG1lbnQgfSBmcm9tIFwiQC90eXBlcy9hcHBvaW50bWVudFwiO1xuXG5leHBvcnQgY29uc3QgU0VSVklDRV9PUFRJT05TID0gW1xuICBcIkJhcmJhIC0gUiQ4MCwwMFwiLFxuICBcIkJhcmJhICYgQ2FiZWxvIC0gUiQxMjAsMDBcIixcbiAgXCJDYWJlbG8gbmEgdGVzb3VyYSAtIFIkMTAwLDAwXCIsXG4gIFwiQ2FiZWxvIG5hIG3DoXF1aW5hXCIsXG5dIGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBTZXJ2aWNlT3B0aW9uID0gKHR5cGVvZiBTRVJWSUNFX09QVElPTlMpW251bWJlcl07XG5cbi8vIOKPsSBEdXJhw6fDo28gZGUgY2FkYSBzZXJ2acOnbyAoZW0gbWludXRvcylcbmNvbnN0IFNFUlZJQ0VfRFVSQVRJT05fTUFQOiBSZWNvcmQ8U2VydmljZU9wdGlvbiwgbnVtYmVyPiA9IHtcbiAgXCJCYXJiYVwiOiAzMCxcbiAgXCJCYXJiYSAmIENhYmVsb1wiOiA2MCxcbiAgXCJDYWJlbG8gbmEgdGVzb3VyYVwiOiA2MCxcbiAgXCJDYWJlbG8gbmEgbcOhcXVpbmFcIjogMzAsXG59O1xuXG4vKipcbiAqIEZ1bsOnw6NvIHJvYnVzdGEgcGFyYSBkZXNjb2JyaXIgYSBkdXJhw6fDo28gZG8gc2VydmnDp29cbiAqIGEgcGFydGlyIGRhIGRlc2NyacOnw6NvIHNhbHZhIG5vIGJhbmNvLlxuICovXG5leHBvcnQgY29uc3QgZ2V0U2VydmljZUR1cmF0aW9uID0gKGRlc2NyaXB0aW9uPzogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgaWYgKCFkZXNjcmlwdGlvbikgcmV0dXJuIDMwO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBkZXNjcmlwdGlvbi50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKFwiYmFyYmEgJiBjYWJlbG9cIikpIHJldHVybiA2MDtcbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aChcImNhYmVsbyBuYSB0ZXNvdXJhXCIpKSByZXR1cm4gNjA7XG4gIGlmIChub3JtYWxpemVkLnN0YXJ0c1dpdGgoXCJiYXJiYSAtIHIkODBcIikpIHJldHVybiAzMDtcbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aChcImNhYmVsbyBuYSBtw6FxdWluYVwiKSkgcmV0dXJuIDMwO1xuXG4gIGNvbnN0IGtleSA9IGRlc2NyaXB0aW9uIGFzIFNlcnZpY2VPcHRpb247XG4gIGlmIChrZXkgaW4gU0VSVklDRV9EVVJBVElPTl9NQVApIHtcbiAgICByZXR1cm4gU0VSVklDRV9EVVJBVElPTl9NQVBba2V5XTtcbiAgfVxuXG4gIHJldHVybiAzMDtcbn07XG5cbmNvbnN0IGdlbmVyYXRlVGltZU9wdGlvbnMgPSAoKTogc3RyaW5nW10gPT4ge1xuICBjb25zdCB0aW1lczogc3RyaW5nW10gPSBbXTtcblxuICBmb3IgKGxldCBob3VyID0gOTsgaG91ciA8PSAyMTsgaG91cisrKSB7XG4gICAgZm9yIChsZXQgbWludXRlID0gMDsgbWludXRlIDwgNjA7IG1pbnV0ZSArPSAzMCkge1xuICAgICAgaWYgKGhvdXIgPT09IDIxICYmIG1pbnV0ZSA+IDApIGJyZWFrO1xuICAgICAgY29uc3QgdGltZVN0cmluZyA9IGAke2hvdXJcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHttaW51dGUudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIil9YDtcbiAgICAgIHRpbWVzLnB1c2godGltZVN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRpbWVzO1xufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfT1BUSU9OUyA9IGdlbmVyYXRlVGltZU9wdGlvbnMoKTtcblxuLy8g8J+UjSBDYWxjdWxhIGhvcsOhcmlvcyBkaXNwb27DrXZlaXMgY29uc2lkZXJhbmRvOlxuLy8gLSBkYXRhIHNlbGVjaW9uYWRhXG4vLyAtIHNlcnZpw6dvIHNlbGVjaW9uYWRvIChkdXJhw6fDo28pXG4vLyAtIGFnZW5kYW1lbnRvcyBleGlzdGVudGVzIChzZW0gc29icmVwb3IpXG4vLyAtIGhvcsOhcmlvcyBwYXNzYWRvcyBubyBkaWEgZGUgaG9qZVxuZXhwb3J0IGNvbnN0IGdldEF2YWlsYWJsZVRpbWVzID0gKHBhcmFtczoge1xuICBkYXRlPzogRGF0ZSB8IG51bGw7XG4gIHNlcnZpY2U/OiBTZXJ2aWNlT3B0aW9uIHwgdW5kZWZpbmVkO1xuICBhcHBvaW50bWVudHM6IEFwcG9pbnRtZW50W107XG4gIGN1cnJlbnRBcHBvaW50bWVudElkPzogc3RyaW5nO1xufSk6IHN0cmluZ1tdID0+IHtcbiAgY29uc3QgeyBkYXRlLCBzZXJ2aWNlLCBhcHBvaW50bWVudHMsIGN1cnJlbnRBcHBvaW50bWVudElkIH0gPSBwYXJhbXM7XG5cbiAgaWYgKCFkYXRlIHx8ICFzZXJ2aWNlKSByZXR1cm4gW107XG5cbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcblxuICBjb25zdCBzZWxlY3RlZER1cmF0aW9uID0gZ2V0U2VydmljZUR1cmF0aW9uKHNlcnZpY2UpO1xuXG4gIGxldCBiYXNlVGltZXMgPSBbLi4uVElNRV9PUFRJT05TXTtcblxuICAvLyBTZSBmb3IgaG9qZSwgcmVtb3ZlIGhvcsOhcmlvcyBxdWUgasOhIHBhc3NhcmFtXG4gIGlmIChpc1NhbWVEYXkoZGF0ZSwgbm93KSkge1xuICAgIGNvbnN0IGN1cnJlbnRNaW51dGVzID0gZ2V0SG91cnMobm93KSAqIDYwICsgZ2V0TWludXRlcyhub3cpO1xuXG4gICAgYmFzZVRpbWVzID0gYmFzZVRpbWVzLmZpbHRlcigodGltZSkgPT4ge1xuICAgICAgY29uc3QgW2hvdXJTdHIsIG1pbnV0ZVN0cl0gPSB0aW1lLnNwbGl0KFwiOlwiKTtcbiAgICAgIGNvbnN0IGhvdXIgPSBOdW1iZXIoaG91clN0cik7XG4gICAgICBjb25zdCBtaW51dGUgPSBOdW1iZXIobWludXRlU3RyKTtcbiAgICAgIGNvbnN0IHRpbWVNaW51dGVzID0gaG91ciAqIDYwICsgbWludXRlO1xuXG4gICAgICByZXR1cm4gdGltZU1pbnV0ZXMgPiBjdXJyZW50TWludXRlcztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbHRyYSBhZ2VuZGFtZW50b3Mgc8OzIGRlc3NlIGRpYSAoaW5kZXBlbmRlbnRlIGRvIGJhcmJlaXJvKVxuICBjb25zdCBkYXlBcHBvaW50bWVudHMgPSBhcHBvaW50bWVudHMuZmlsdGVyKChhcHB0KSA9PlxuICAgIGlzU2FtZURheShuZXcgRGF0ZShhcHB0LnNjaGVkdWxlQXQpLCBkYXRlKSxcbiAgKTtcblxuICAvLyBSZW1vdmUgaG9yw6FyaW9zIHF1ZSBjb2xpZGVtIGNvbSBxdWFscXVlciBhZ2VuZGFtZW50byBleGlzdGVudGVcbiAgY29uc3QgYXZhaWxhYmxlVGltZXMgPSBiYXNlVGltZXMuZmlsdGVyKCh0aW1lKSA9PiB7XG4gICAgY29uc3QgW2hvdXJTdHIsIG1pbnV0ZVN0cl0gPSB0aW1lLnNwbGl0KFwiOlwiKTtcbiAgICBjb25zdCBob3VyID0gTnVtYmVyKGhvdXJTdHIpO1xuICAgIGNvbnN0IG1pbnV0ZSA9IE51bWJlcihtaW51dGVTdHIpO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVN0YXJ0ID0gaG91ciAqIDYwICsgbWludXRlO1xuICAgIGNvbnN0IGNhbmRpZGF0ZUVuZCA9IGNhbmRpZGF0ZVN0YXJ0ICsgc2VsZWN0ZWREdXJhdGlvbjtcblxuICAgIGZvciAoY29uc3QgYXBwdCBvZiBkYXlBcHBvaW50bWVudHMpIHtcbiAgICAgIGlmIChjdXJyZW50QXBwb2ludG1lbnRJZCAmJiBhcHB0LmlkID09PSBjdXJyZW50QXBwb2ludG1lbnRJZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IGFwcHREYXRlID0gbmV3IERhdGUoYXBwdC5zY2hlZHVsZUF0KTtcbiAgICAgIGNvbnN0IGFwcHRTdGFydCA9IGdldEhvdXJzKGFwcHREYXRlKSAqIDYwICsgZ2V0TWludXRlcyhhcHB0RGF0ZSk7XG4gICAgICBjb25zdCBhcHB0RHVyYXRpb24gPSBnZXRTZXJ2aWNlRHVyYXRpb24oYXBwdC5kZXNjcmlwdGlvbik7XG4gICAgICBjb25zdCBhcHB0RW5kID0gYXBwdFN0YXJ0ICsgYXBwdER1cmF0aW9uO1xuXG4gICAgICBjb25zdCBvdmVybGFwID0gY2FuZGlkYXRlU3RhcnQgPCBhcHB0RW5kICYmIGFwcHRTdGFydCA8IGNhbmRpZGF0ZUVuZDtcblxuICAgICAgaWYgKG92ZXJsYXApIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGF2YWlsYWJsZVRpbWVzO1xufTtcbiJdLCJuYW1lcyI6WyJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJpc1NhbWVEYXkiLCJTRVJWSUNFX09QVElPTlMiLCJTRVJWSUNFX0RVUkFUSU9OX01BUCIsImdldFNlcnZpY2VEdXJhdGlvbiIsImRlc2NyaXB0aW9uIiwibm9ybWFsaXplZCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJrZXkiLCJnZW5lcmF0ZVRpbWVPcHRpb25zIiwidGltZXMiLCJob3VyIiwibWludXRlIiwidGltZVN0cmluZyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJwdXNoIiwiVElNRV9PUFRJT05TIiwiZ2V0QXZhaWxhYmxlVGltZXMiLCJwYXJhbXMiLCJkYXRlIiwic2VydmljZSIsImFwcG9pbnRtZW50cyIsImN1cnJlbnRBcHBvaW50bWVudElkIiwibm93IiwiRGF0ZSIsInNlbGVjdGVkRHVyYXRpb24iLCJiYXNlVGltZXMiLCJjdXJyZW50TWludXRlcyIsImZpbHRlciIsInRpbWUiLCJob3VyU3RyIiwibWludXRlU3RyIiwic3BsaXQiLCJOdW1iZXIiLCJ0aW1lTWludXRlcyIsImRheUFwcG9pbnRtZW50cyIsImFwcHQiLCJzY2hlZHVsZUF0IiwiYXZhaWxhYmxlVGltZXMiLCJjYW5kaWRhdGVTdGFydCIsImNhbmRpZGF0ZUVuZCIsImlkIiwiYXBwdERhdGUiLCJhcHB0U3RhcnQiLCJhcHB0RHVyYXRpb24iLCJhcHB0RW5kIiwib3ZlcmxhcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/appointment-form/constants-and-utils.ts\n',
        ),
      );

      /***/
    },
});
