"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page", {
  /***/ "(app-pages-browser)/./src/components/appointment-form/constants-and-utils.ts":
    /*!****************************************************************!*\
  !*** ./src/components/appointment-form/constants-and-utils.ts ***!
  \****************************************************************/
    /***/ (module, __webpack_exports__, __webpack_require__) => {
      eval(
        __webpack_require__.ts(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SERVICE_OPTIONS: () => (/* binding */ SERVICE_OPTIONS),\n/* harmony export */   TIME_OPTIONS: () => (/* binding */ TIME_OPTIONS),\n/* harmony export */   getAvailableTimes: () => (/* binding */ getAvailableTimes),\n/* harmony export */   getServiceDuration: () => (/* binding */ getServiceDuration)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/isSameDay.js");\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/getHours.js");\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/getMinutes.js");\n\nconst SERVICE_OPTIONS = [\n    "Barba - R$80,00",\n    "Barba & Cabelo - R$120,00",\n    "Cabelo na tesoura - R$100,00",\n    "Cabelo na mÃ¡quina - R$90,00"\n];\n// â± DuraÃ§Ã£o de cada serviÃ§o (em minutos)\nconst SERVICE_DURATION_MAP = {\n    "Barba - R$80,00": 30,\n    "Barba & Cabelo - R$120,00": 60,\n    "Cabelo na tesoura - R$100,00": 60,\n    "Cabelo na mÃ¡quina - R$90,00": 30\n};\n/**\n * FunÃ§Ã£o robusta para descobrir a duraÃ§Ã£o do serviÃ§o\n * a partir da descriÃ§Ã£o salva no banco.\n */ const getServiceDuration = (description)=>{\n    if (!description) return 30;\n    const normalized = description.trim().toLowerCase();\n    if (normalized.startsWith("barba & cabelo")) return 60;\n    if (normalized.startsWith("cabelo na tesoura")) return 60;\n    if (normalized.startsWith("barba - r$80")) return 30;\n    if (normalized.startsWith("cabelo na mÃ¡quina")) return 30;\n    const key = description;\n    if (key in SERVICE_DURATION_MAP) {\n        return SERVICE_DURATION_MAP[key];\n    }\n    return 30;\n};\nconst generateTimeOptions = ()=>{\n    const times = [];\n    for(let hour = 9; hour <= 21; hour++){\n        for(let minute = 0; minute < 60; minute += 30){\n            if (hour === 21 && minute > 0) break;\n            const timeString = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`;\n            times.push(timeString);\n        }\n    }\n    return times;\n};\nconst TIME_OPTIONS = generateTimeOptions();\n// ðŸ” Calcula horÃ¡rios disponÃ­veis considerando:\n// - data selecionada\n// - serviÃ§o selecionado (duraÃ§Ã£o)\n// - agendamentos existentes (sem sobrepor)\n// - horÃ¡rios passados no dia de hoje\nconst getAvailableTimes = (params)=>{\n    const { date, service, appointments, currentAppointmentId } = params;\n    if (!date || !service) return [];\n    const now = new Date();\n    const selectedDuration = getServiceDuration(service);\n    let baseTimes = [\n        ...TIME_OPTIONS\n    ];\n    // Se for hoje, remove horÃ¡rios que jÃ¡ passaram\n    if ((0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(date, now)) {\n        const currentMinutes = (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__.getHours)(now) * 60 + (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.getMinutes)(now);\n        baseTimes = baseTimes.filter((time)=>{\n            const [hourStr, minuteStr] = time.split(":");\n            const hour = Number(hourStr);\n            const minute = Number(minuteStr);\n            const timeMinutes = hour * 60 + minute;\n            return timeMinutes > currentMinutes;\n        });\n    }\n    // Filtra agendamentos sÃ³ desse dia (independente do barbeiro)\n    const dayAppointments = appointments.filter((appt)=>(0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(new Date(appt.scheduleAt), date));\n    // Remove horÃ¡rios que colidem com qualquer agendamento existente\n    const availableTimes = baseTimes.filter((time)=>{\n        const [hourStr, minuteStr] = time.split(":");\n        const hour = Number(hourStr);\n        const minute = Number(minuteStr);\n        const candidateStart = hour * 60 + minute;\n        const candidateEnd = candidateStart + selectedDuration;\n        for (const appt of dayAppointments){\n            if (currentAppointmentId && appt.id === currentAppointmentId) continue;\n            const apptDate = new Date(appt.scheduleAt);\n            const apptStart = (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__.getHours)(apptDate) * 60 + (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.getMinutes)(apptDate);\n            const apptDuration = getServiceDuration(appt.description);\n            const apptEnd = apptStart + apptDuration;\n            const overlap = candidateStart < apptEnd && apptStart < candidateEnd;\n            if (overlap) return false;\n        }\n        return true;\n    });\n    return availableTimes;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2FwcG9pbnRtZW50LWZvcm0vY29uc3RhbnRzLWFuZC11dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJEO0FBR3BELE1BQU1HLGtCQUFrQjtJQUM3QjtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQVU7QUFJWCx5Q0FBeUM7QUFDekMsTUFBTUMsdUJBQXNEO0lBQzFELG1CQUFtQjtJQUNuQiw2QkFBNkI7SUFDN0IsZ0NBQWdDO0lBQ2hDLCtCQUErQjtBQUNqQztBQUVBOzs7Q0FHQyxHQUNNLE1BQU1DLHFCQUFxQixDQUFDQztJQUNqQyxJQUFJLENBQUNBLGFBQWEsT0FBTztJQUV6QixNQUFNQyxhQUFhRCxZQUFZRSxJQUFJLEdBQUdDLFdBQVc7SUFFakQsSUFBSUYsV0FBV0csVUFBVSxDQUFDLG1CQUFtQixPQUFPO0lBQ3BELElBQUlILFdBQVdHLFVBQVUsQ0FBQyxzQkFBc0IsT0FBTztJQUN2RCxJQUFJSCxXQUFXRyxVQUFVLENBQUMsaUJBQWlCLE9BQU87SUFDbEQsSUFBSUgsV0FBV0csVUFBVSxDQUFDLHNCQUFzQixPQUFPO0lBRXZELE1BQU1DLE1BQU1MO0lBQ1osSUFBSUssT0FBT1Asc0JBQXNCO1FBQy9CLE9BQU9BLG9CQUFvQixDQUFDTyxJQUFJO0lBQ2xDO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFRixNQUFNQyxzQkFBc0I7SUFDMUIsTUFBTUMsUUFBa0IsRUFBRTtJQUUxQixJQUFLLElBQUlDLE9BQU8sR0FBR0EsUUFBUSxJQUFJQSxPQUFRO1FBQ3JDLElBQUssSUFBSUMsU0FBUyxHQUFHQSxTQUFTLElBQUlBLFVBQVUsR0FBSTtZQUM5QyxJQUFJRCxTQUFTLE1BQU1DLFNBQVMsR0FBRztZQUMvQixNQUFNQyxhQUFhLEdBQUdGLEtBQ25CRyxRQUFRLEdBQ1JDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFSCxPQUFPRSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHLE1BQU07WUFDM0RMLE1BQU1NLElBQUksQ0FBQ0g7UUFDYjtJQUNGO0lBRUEsT0FBT0g7QUFDVDtBQUVPLE1BQU1PLGVBQWVSLHNCQUFzQjtBQUVsRCxnREFBZ0Q7QUFDaEQscUJBQXFCO0FBQ3JCLGtDQUFrQztBQUNsQywyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQzlCLE1BQU1TLG9CQUFvQixDQUFDQztJQU1oQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdKO0lBRTlELElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLE9BQU8sRUFBRTtJQUVoQyxNQUFNRyxNQUFNLElBQUlDO0lBRWhCLE1BQU1DLG1CQUFtQnhCLG1CQUFtQm1CO0lBRTVDLElBQUlNLFlBQVk7V0FBSVY7S0FBYTtJQUVqQywrQ0FBK0M7SUFDL0MsSUFBSWxCLHdHQUFTQSxDQUFDcUIsTUFBTUksTUFBTTtRQUN4QixNQUFNSSxpQkFBaUIvQix1R0FBUUEsQ0FBQzJCLE9BQU8sS0FBSzFCLHlHQUFVQSxDQUFDMEI7UUFFdkRHLFlBQVlBLFVBQVVFLE1BQU0sQ0FBQyxDQUFDQztZQUM1QixNQUFNLENBQUNDLFNBQVNDLFVBQVUsR0FBR0YsS0FBS0csS0FBSyxDQUFDO1lBQ3hDLE1BQU10QixPQUFPdUIsT0FBT0g7WUFDcEIsTUFBTW5CLFNBQVNzQixPQUFPRjtZQUN0QixNQUFNRyxjQUFjeEIsT0FBTyxLQUFLQztZQUVoQyxPQUFPdUIsY0FBY1A7UUFDdkI7SUFDRjtJQUVBLDhEQUE4RDtJQUM5RCxNQUFNUSxrQkFBa0JkLGFBQWFPLE1BQU0sQ0FBQyxDQUFDUSxPQUMzQ3RDLHdHQUFTQSxDQUFDLElBQUkwQixLQUFLWSxLQUFLQyxVQUFVLEdBQUdsQjtJQUd2QyxpRUFBaUU7SUFDakUsTUFBTW1CLGlCQUFpQlosVUFBVUUsTUFBTSxDQUFDLENBQUNDO1FBQ3ZDLE1BQU0sQ0FBQ0MsU0FBU0MsVUFBVSxHQUFHRixLQUFLRyxLQUFLLENBQUM7UUFDeEMsTUFBTXRCLE9BQU91QixPQUFPSDtRQUNwQixNQUFNbkIsU0FBU3NCLE9BQU9GO1FBQ3RCLE1BQU1RLGlCQUFpQjdCLE9BQU8sS0FBS0M7UUFDbkMsTUFBTTZCLGVBQWVELGlCQUFpQmQ7UUFFdEMsS0FBSyxNQUFNVyxRQUFRRCxnQkFBaUI7WUFDbEMsSUFBSWIsd0JBQXdCYyxLQUFLSyxFQUFFLEtBQUtuQixzQkFBc0I7WUFFOUQsTUFBTW9CLFdBQVcsSUFBSWxCLEtBQUtZLEtBQUtDLFVBQVU7WUFDekMsTUFBTU0sWUFBWS9DLHVHQUFRQSxDQUFDOEMsWUFBWSxLQUFLN0MseUdBQVVBLENBQUM2QztZQUN2RCxNQUFNRSxlQUFlM0MsbUJBQW1CbUMsS0FBS2xDLFdBQVc7WUFDeEQsTUFBTTJDLFVBQVVGLFlBQVlDO1lBRTVCLE1BQU1FLFVBQVVQLGlCQUFpQk0sV0FBV0YsWUFBWUg7WUFFeEQsSUFBSU0sU0FBUyxPQUFPO1FBQ3RCO1FBRUEsT0FBTztJQUNUO0lBRUEsT0FBT1I7QUFDVCxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYnJ1bm9sZWFsL0RvY3VtZW50cy9DdXJzb3MvTkVYVEpTL2JhcmJlYXJpYS9zcmMvY29tcG9uZW50cy9hcHBvaW50bWVudC1mb3JtL2NvbnN0YW50cy1hbmQtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SG91cnMsIGdldE1pbnV0ZXMsIGlzU2FtZURheSB9IGZyb20gXCJkYXRlLWZuc1wiO1xuaW1wb3J0IHsgQXBwb2ludG1lbnQgfSBmcm9tIFwiQC90eXBlcy9hcHBvaW50bWVudFwiO1xuXG5leHBvcnQgY29uc3QgU0VSVklDRV9PUFRJT05TID0gW1xuICBcIkJhcmJhIC0gUiQ4MCwwMFwiLFxuICBcIkJhcmJhICYgQ2FiZWxvIC0gUiQxMjAsMDBcIixcbiAgXCJDYWJlbG8gbmEgdGVzb3VyYSAtIFIkMTAwLDAwXCIsXG4gIFwiQ2FiZWxvIG5hIG3DoXF1aW5hIC0gUiQ5MCwwMFwiLFxuXSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgU2VydmljZU9wdGlvbiA9ICh0eXBlb2YgU0VSVklDRV9PUFRJT05TKVtudW1iZXJdO1xuXG4vLyDij7EgRHVyYcOnw6NvIGRlIGNhZGEgc2VydmnDp28gKGVtIG1pbnV0b3MpXG5jb25zdCBTRVJWSUNFX0RVUkFUSU9OX01BUDogUmVjb3JkPFNlcnZpY2VPcHRpb24sIG51bWJlcj4gPSB7XG4gIFwiQmFyYmEgLSBSJDgwLDAwXCI6IDMwLFxuICBcIkJhcmJhICYgQ2FiZWxvIC0gUiQxMjAsMDBcIjogNjAsXG4gIFwiQ2FiZWxvIG5hIHRlc291cmEgLSBSJDEwMCwwMFwiOiA2MCxcbiAgXCJDYWJlbG8gbmEgbcOhcXVpbmEgLSBSJDkwLDAwXCI6IDMwLFxufTtcblxuLyoqXG4gKiBGdW7Dp8OjbyByb2J1c3RhIHBhcmEgZGVzY29icmlyIGEgZHVyYcOnw6NvIGRvIHNlcnZpw6dvXG4gKiBhIHBhcnRpciBkYSBkZXNjcmnDp8OjbyBzYWx2YSBubyBiYW5jby5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNlcnZpY2VEdXJhdGlvbiA9IChkZXNjcmlwdGlvbj86IHN0cmluZyk6IG51bWJlciA9PiB7XG4gIGlmICghZGVzY3JpcHRpb24pIHJldHVybiAzMDtcblxuICBjb25zdCBub3JtYWxpemVkID0gZGVzY3JpcHRpb24udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aChcImJhcmJhICYgY2FiZWxvXCIpKSByZXR1cm4gNjA7XG4gIGlmIChub3JtYWxpemVkLnN0YXJ0c1dpdGgoXCJjYWJlbG8gbmEgdGVzb3VyYVwiKSkgcmV0dXJuIDYwO1xuICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKFwiYmFyYmEgLSByJDgwXCIpKSByZXR1cm4gMzA7XG4gIGlmIChub3JtYWxpemVkLnN0YXJ0c1dpdGgoXCJjYWJlbG8gbmEgbcOhcXVpbmFcIikpIHJldHVybiAzMDtcblxuICBjb25zdCBrZXkgPSBkZXNjcmlwdGlvbiBhcyBTZXJ2aWNlT3B0aW9uO1xuICBpZiAoa2V5IGluIFNFUlZJQ0VfRFVSQVRJT05fTUFQKSB7XG4gICAgcmV0dXJuIFNFUlZJQ0VfRFVSQVRJT05fTUFQW2tleV07XG4gIH1cblxuICByZXR1cm4gMzA7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVRpbWVPcHRpb25zID0gKCk6IHN0cmluZ1tdID0+IHtcbiAgY29uc3QgdGltZXM6IHN0cmluZ1tdID0gW107XG5cbiAgZm9yIChsZXQgaG91ciA9IDk7IGhvdXIgPD0gMjE7IGhvdXIrKykge1xuICAgIGZvciAobGV0IG1pbnV0ZSA9IDA7IG1pbnV0ZSA8IDYwOyBtaW51dGUgKz0gMzApIHtcbiAgICAgIGlmIChob3VyID09PSAyMSAmJiBtaW51dGUgPiAwKSBicmVhaztcbiAgICAgIGNvbnN0IHRpbWVTdHJpbmcgPSBgJHtob3VyXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9OiR7bWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpfWA7XG4gICAgICB0aW1lcy5wdXNoKHRpbWVTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aW1lcztcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX09QVElPTlMgPSBnZW5lcmF0ZVRpbWVPcHRpb25zKCk7XG5cbi8vIPCflI0gQ2FsY3VsYSBob3LDoXJpb3MgZGlzcG9uw612ZWlzIGNvbnNpZGVyYW5kbzpcbi8vIC0gZGF0YSBzZWxlY2lvbmFkYVxuLy8gLSBzZXJ2acOnbyBzZWxlY2lvbmFkbyAoZHVyYcOnw6NvKVxuLy8gLSBhZ2VuZGFtZW50b3MgZXhpc3RlbnRlcyAoc2VtIHNvYnJlcG9yKVxuLy8gLSBob3LDoXJpb3MgcGFzc2Fkb3Mgbm8gZGlhIGRlIGhvamVcbmV4cG9ydCBjb25zdCBnZXRBdmFpbGFibGVUaW1lcyA9IChwYXJhbXM6IHtcbiAgZGF0ZT86IERhdGUgfCBudWxsO1xuICBzZXJ2aWNlPzogU2VydmljZU9wdGlvbiB8IHVuZGVmaW5lZDtcbiAgYXBwb2ludG1lbnRzOiBBcHBvaW50bWVudFtdO1xuICBjdXJyZW50QXBwb2ludG1lbnRJZD86IHN0cmluZztcbn0pOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IHsgZGF0ZSwgc2VydmljZSwgYXBwb2ludG1lbnRzLCBjdXJyZW50QXBwb2ludG1lbnRJZCB9ID0gcGFyYW1zO1xuXG4gIGlmICghZGF0ZSB8fCAhc2VydmljZSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgY29uc3Qgc2VsZWN0ZWREdXJhdGlvbiA9IGdldFNlcnZpY2VEdXJhdGlvbihzZXJ2aWNlKTtcblxuICBsZXQgYmFzZVRpbWVzID0gWy4uLlRJTUVfT1BUSU9OU107XG5cbiAgLy8gU2UgZm9yIGhvamUsIHJlbW92ZSBob3LDoXJpb3MgcXVlIGrDoSBwYXNzYXJhbVxuICBpZiAoaXNTYW1lRGF5KGRhdGUsIG5vdykpIHtcbiAgICBjb25zdCBjdXJyZW50TWludXRlcyA9IGdldEhvdXJzKG5vdykgKiA2MCArIGdldE1pbnV0ZXMobm93KTtcblxuICAgIGJhc2VUaW1lcyA9IGJhc2VUaW1lcy5maWx0ZXIoKHRpbWUpID0+IHtcbiAgICAgIGNvbnN0IFtob3VyU3RyLCBtaW51dGVTdHJdID0gdGltZS5zcGxpdChcIjpcIik7XG4gICAgICBjb25zdCBob3VyID0gTnVtYmVyKGhvdXJTdHIpO1xuICAgICAgY29uc3QgbWludXRlID0gTnVtYmVyKG1pbnV0ZVN0cik7XG4gICAgICBjb25zdCB0aW1lTWludXRlcyA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcblxuICAgICAgcmV0dXJuIHRpbWVNaW51dGVzID4gY3VycmVudE1pbnV0ZXM7XG4gICAgfSk7XG4gIH1cblxuICAvLyBGaWx0cmEgYWdlbmRhbWVudG9zIHPDsyBkZXNzZSBkaWEgKGluZGVwZW5kZW50ZSBkbyBiYXJiZWlybylcbiAgY29uc3QgZGF5QXBwb2ludG1lbnRzID0gYXBwb2ludG1lbnRzLmZpbHRlcigoYXBwdCkgPT5cbiAgICBpc1NhbWVEYXkobmV3IERhdGUoYXBwdC5zY2hlZHVsZUF0KSwgZGF0ZSksXG4gICk7XG5cbiAgLy8gUmVtb3ZlIGhvcsOhcmlvcyBxdWUgY29saWRlbSBjb20gcXVhbHF1ZXIgYWdlbmRhbWVudG8gZXhpc3RlbnRlXG4gIGNvbnN0IGF2YWlsYWJsZVRpbWVzID0gYmFzZVRpbWVzLmZpbHRlcigodGltZSkgPT4ge1xuICAgIGNvbnN0IFtob3VyU3RyLCBtaW51dGVTdHJdID0gdGltZS5zcGxpdChcIjpcIik7XG4gICAgY29uc3QgaG91ciA9IE51bWJlcihob3VyU3RyKTtcbiAgICBjb25zdCBtaW51dGUgPSBOdW1iZXIobWludXRlU3RyKTtcbiAgICBjb25zdCBjYW5kaWRhdGVTdGFydCA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcbiAgICBjb25zdCBjYW5kaWRhdGVFbmQgPSBjYW5kaWRhdGVTdGFydCArIHNlbGVjdGVkRHVyYXRpb247XG5cbiAgICBmb3IgKGNvbnN0IGFwcHQgb2YgZGF5QXBwb2ludG1lbnRzKSB7XG4gICAgICBpZiAoY3VycmVudEFwcG9pbnRtZW50SWQgJiYgYXBwdC5pZCA9PT0gY3VycmVudEFwcG9pbnRtZW50SWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBhcHB0RGF0ZSA9IG5ldyBEYXRlKGFwcHQuc2NoZWR1bGVBdCk7XG4gICAgICBjb25zdCBhcHB0U3RhcnQgPSBnZXRIb3VycyhhcHB0RGF0ZSkgKiA2MCArIGdldE1pbnV0ZXMoYXBwdERhdGUpO1xuICAgICAgY29uc3QgYXBwdER1cmF0aW9uID0gZ2V0U2VydmljZUR1cmF0aW9uKGFwcHQuZGVzY3JpcHRpb24pO1xuICAgICAgY29uc3QgYXBwdEVuZCA9IGFwcHRTdGFydCArIGFwcHREdXJhdGlvbjtcblxuICAgICAgY29uc3Qgb3ZlcmxhcCA9IGNhbmRpZGF0ZVN0YXJ0IDwgYXBwdEVuZCAmJiBhcHB0U3RhcnQgPCBjYW5kaWRhdGVFbmQ7XG5cbiAgICAgIGlmIChvdmVybGFwKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBhdmFpbGFibGVUaW1lcztcbn07XG4iXSwibmFtZXMiOlsiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiaXNTYW1lRGF5IiwiU0VSVklDRV9PUFRJT05TIiwiU0VSVklDRV9EVVJBVElPTl9NQVAiLCJnZXRTZXJ2aWNlRHVyYXRpb24iLCJkZXNjcmlwdGlvbiIsIm5vcm1hbGl6ZWQiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwia2V5IiwiZ2VuZXJhdGVUaW1lT3B0aW9ucyIsInRpbWVzIiwiaG91ciIsIm1pbnV0ZSIsInRpbWVTdHJpbmciLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwicHVzaCIsIlRJTUVfT1BUSU9OUyIsImdldEF2YWlsYWJsZVRpbWVzIiwicGFyYW1zIiwiZGF0ZSIsInNlcnZpY2UiLCJhcHBvaW50bWVudHMiLCJjdXJyZW50QXBwb2ludG1lbnRJZCIsIm5vdyIsIkRhdGUiLCJzZWxlY3RlZER1cmF0aW9uIiwiYmFzZVRpbWVzIiwiY3VycmVudE1pbnV0ZXMiLCJmaWx0ZXIiLCJ0aW1lIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInNwbGl0IiwiTnVtYmVyIiwidGltZU1pbnV0ZXMiLCJkYXlBcHBvaW50bWVudHMiLCJhcHB0Iiwic2NoZWR1bGVBdCIsImF2YWlsYWJsZVRpbWVzIiwiY2FuZGlkYXRlU3RhcnQiLCJjYW5kaWRhdGVFbmQiLCJpZCIsImFwcHREYXRlIiwiYXBwdFN0YXJ0IiwiYXBwdER1cmF0aW9uIiwiYXBwdEVuZCIsIm92ZXJsYXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/appointment-form/constants-and-utils.ts\n',
        ),
      );

      /***/
    },
});
