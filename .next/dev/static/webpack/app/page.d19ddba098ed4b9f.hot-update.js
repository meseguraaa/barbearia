"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page", {
  /***/ "(app-pages-browser)/./src/components/appointment-form/constants-and-utils.ts":
    /*!****************************************************************!*\
  !*** ./src/components/appointment-form/constants-and-utils.ts ***!
  \****************************************************************/
    /***/ (module, __webpack_exports__, __webpack_require__) => {
      eval(
        __webpack_require__.ts(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SERVICE_OPTIONS: () => (/* binding */ SERVICE_OPTIONS),\n/* harmony export */   TIME_OPTIONS: () => (/* binding */ TIME_OPTIONS),\n/* harmony export */   getAvailableTimes: () => (/* binding */ getAvailableTimes),\n/* harmony export */   getServiceDuration: () => (/* binding */ getServiceDuration)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/isSameDay.js");\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/getHours.js");\n/* harmony import */ var _barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=getHours,getMinutes,isSameDay!=!date-fns */ "(app-pages-browser)/./node_modules/date-fns/getMinutes.js");\n\nconst SERVICE_OPTIONS = [\n    "Barba - R$80,00",\n    "Barba & Cabelo",\n    "Cabelo na tesoura",\n    "Cabelo na mÃ¡quina"\n];\n// â± DuraÃ§Ã£o de cada serviÃ§o (em minutos)\nconst SERVICE_DURATION_MAP = {\n    "Barba": 30,\n    "Barba & Cabelo": 60,\n    "Cabelo na tesoura": 60,\n    "Cabelo na mÃ¡quina": 30\n};\n/**\n * FunÃ§Ã£o robusta para descobrir a duraÃ§Ã£o do serviÃ§o\n * a partir da descriÃ§Ã£o salva no banco.\n */ const getServiceDuration = (description)=>{\n    if (!description) return 30;\n    const normalized = description.trim().toLowerCase();\n    if (normalized.startsWith("barba & cabelo")) return 60;\n    if (normalized.startsWith("cabelo na tesoura")) return 60;\n    if (normalized.startsWith("barba - r$80")) return 30;\n    if (normalized.startsWith("cabelo na mÃ¡quina")) return 30;\n    const key = description;\n    if (key in SERVICE_DURATION_MAP) {\n        return SERVICE_DURATION_MAP[key];\n    }\n    return 30;\n};\nconst generateTimeOptions = ()=>{\n    const times = [];\n    for(let hour = 9; hour <= 21; hour++){\n        for(let minute = 0; minute < 60; minute += 30){\n            if (hour === 21 && minute > 0) break;\n            const timeString = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`;\n            times.push(timeString);\n        }\n    }\n    return times;\n};\nconst TIME_OPTIONS = generateTimeOptions();\n// ðŸ” Calcula horÃ¡rios disponÃ­veis considerando:\n// - data selecionada\n// - serviÃ§o selecionado (duraÃ§Ã£o)\n// - agendamentos existentes (sem sobrepor)\n// - horÃ¡rios passados no dia de hoje\nconst getAvailableTimes = (params)=>{\n    const { date, service, appointments, currentAppointmentId } = params;\n    if (!date || !service) return [];\n    const now = new Date();\n    const selectedDuration = getServiceDuration(service);\n    let baseTimes = [\n        ...TIME_OPTIONS\n    ];\n    // Se for hoje, remove horÃ¡rios que jÃ¡ passaram\n    if ((0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(date, now)) {\n        const currentMinutes = (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__.getHours)(now) * 60 + (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.getMinutes)(now);\n        baseTimes = baseTimes.filter((time)=>{\n            const [hourStr, minuteStr] = time.split(":");\n            const hour = Number(hourStr);\n            const minute = Number(minuteStr);\n            const timeMinutes = hour * 60 + minute;\n            return timeMinutes > currentMinutes;\n        });\n    }\n    // Filtra agendamentos sÃ³ desse dia (independente do barbeiro)\n    const dayAppointments = appointments.filter((appt)=>(0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_0__.isSameDay)(new Date(appt.scheduleAt), date));\n    // Remove horÃ¡rios que colidem com qualquer agendamento existente\n    const availableTimes = baseTimes.filter((time)=>{\n        const [hourStr, minuteStr] = time.split(":");\n        const hour = Number(hourStr);\n        const minute = Number(minuteStr);\n        const candidateStart = hour * 60 + minute;\n        const candidateEnd = candidateStart + selectedDuration;\n        for (const appt of dayAppointments){\n            if (currentAppointmentId && appt.id === currentAppointmentId) continue;\n            const apptDate = new Date(appt.scheduleAt);\n            const apptStart = (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_1__.getHours)(apptDate) * 60 + (0,_barrel_optimize_names_getHours_getMinutes_isSameDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.getMinutes)(apptDate);\n            const apptDuration = getServiceDuration(appt.description);\n            const apptEnd = apptStart + apptDuration;\n            const overlap = candidateStart < apptEnd && apptStart < candidateEnd;\n            if (overlap) return false;\n        }\n        return true;\n    });\n    return availableTimes;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2FwcG9pbnRtZW50LWZvcm0vY29uc3RhbnRzLWFuZC11dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJEO0FBR3BELE1BQU1HLGtCQUFrQjtJQUM3QjtJQUNBO0lBQ0E7SUFDQTtDQUNELENBQVU7QUFJWCx5Q0FBeUM7QUFDekMsTUFBTUMsdUJBQXNEO0lBQzFELFNBQVM7SUFDVCxrQkFBa0I7SUFDbEIscUJBQXFCO0lBQ3JCLHFCQUFxQjtBQUN2QjtBQUVBOzs7Q0FHQyxHQUNNLE1BQU1DLHFCQUFxQixDQUFDQztJQUNqQyxJQUFJLENBQUNBLGFBQWEsT0FBTztJQUV6QixNQUFNQyxhQUFhRCxZQUFZRSxJQUFJLEdBQUdDLFdBQVc7SUFFakQsSUFBSUYsV0FBV0csVUFBVSxDQUFDLG1CQUFtQixPQUFPO0lBQ3BELElBQUlILFdBQVdHLFVBQVUsQ0FBQyxzQkFBc0IsT0FBTztJQUN2RCxJQUFJSCxXQUFXRyxVQUFVLENBQUMsaUJBQWlCLE9BQU87SUFDbEQsSUFBSUgsV0FBV0csVUFBVSxDQUFDLHNCQUFzQixPQUFPO0lBRXZELE1BQU1DLE1BQU1MO0lBQ1osSUFBSUssT0FBT1Asc0JBQXNCO1FBQy9CLE9BQU9BLG9CQUFvQixDQUFDTyxJQUFJO0lBQ2xDO0lBRUEsT0FBTztBQUNULEVBQUU7QUFFRixNQUFNQyxzQkFBc0I7SUFDMUIsTUFBTUMsUUFBa0IsRUFBRTtJQUUxQixJQUFLLElBQUlDLE9BQU8sR0FBR0EsUUFBUSxJQUFJQSxPQUFRO1FBQ3JDLElBQUssSUFBSUMsU0FBUyxHQUFHQSxTQUFTLElBQUlBLFVBQVUsR0FBSTtZQUM5QyxJQUFJRCxTQUFTLE1BQU1DLFNBQVMsR0FBRztZQUMvQixNQUFNQyxhQUFhLEdBQUdGLEtBQ25CRyxRQUFRLEdBQ1JDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFSCxPQUFPRSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHLE1BQU07WUFDM0RMLE1BQU1NLElBQUksQ0FBQ0g7UUFDYjtJQUNGO0lBRUEsT0FBT0g7QUFDVDtBQUVPLE1BQU1PLGVBQWVSLHNCQUFzQjtBQUVsRCxnREFBZ0Q7QUFDaEQscUJBQXFCO0FBQ3JCLGtDQUFrQztBQUNsQywyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQzlCLE1BQU1TLG9CQUFvQixDQUFDQztJQU1oQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdKO0lBRTlELElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLE9BQU8sRUFBRTtJQUVoQyxNQUFNRyxNQUFNLElBQUlDO0lBRWhCLE1BQU1DLG1CQUFtQnhCLG1CQUFtQm1CO0lBRTVDLElBQUlNLFlBQVk7V0FBSVY7S0FBYTtJQUVqQywrQ0FBK0M7SUFDL0MsSUFBSWxCLHdHQUFTQSxDQUFDcUIsTUFBTUksTUFBTTtRQUN4QixNQUFNSSxpQkFBaUIvQix1R0FBUUEsQ0FBQzJCLE9BQU8sS0FBSzFCLHlHQUFVQSxDQUFDMEI7UUFFdkRHLFlBQVlBLFVBQVVFLE1BQU0sQ0FBQyxDQUFDQztZQUM1QixNQUFNLENBQUNDLFNBQVNDLFVBQVUsR0FBR0YsS0FBS0csS0FBSyxDQUFDO1lBQ3hDLE1BQU10QixPQUFPdUIsT0FBT0g7WUFDcEIsTUFBTW5CLFNBQVNzQixPQUFPRjtZQUN0QixNQUFNRyxjQUFjeEIsT0FBTyxLQUFLQztZQUVoQyxPQUFPdUIsY0FBY1A7UUFDdkI7SUFDRjtJQUVBLDhEQUE4RDtJQUM5RCxNQUFNUSxrQkFBa0JkLGFBQWFPLE1BQU0sQ0FBQyxDQUFDUSxPQUMzQ3RDLHdHQUFTQSxDQUFDLElBQUkwQixLQUFLWSxLQUFLQyxVQUFVLEdBQUdsQjtJQUd2QyxpRUFBaUU7SUFDakUsTUFBTW1CLGlCQUFpQlosVUFBVUUsTUFBTSxDQUFDLENBQUNDO1FBQ3ZDLE1BQU0sQ0FBQ0MsU0FBU0MsVUFBVSxHQUFHRixLQUFLRyxLQUFLLENBQUM7UUFDeEMsTUFBTXRCLE9BQU91QixPQUFPSDtRQUNwQixNQUFNbkIsU0FBU3NCLE9BQU9GO1FBQ3RCLE1BQU1RLGlCQUFpQjdCLE9BQU8sS0FBS0M7UUFDbkMsTUFBTTZCLGVBQWVELGlCQUFpQmQ7UUFFdEMsS0FBSyxNQUFNVyxRQUFRRCxnQkFBaUI7WUFDbEMsSUFBSWIsd0JBQXdCYyxLQUFLSyxFQUFFLEtBQUtuQixzQkFBc0I7WUFFOUQsTUFBTW9CLFdBQVcsSUFBSWxCLEtBQUtZLEtBQUtDLFVBQVU7WUFDekMsTUFBTU0sWUFBWS9DLHVHQUFRQSxDQUFDOEMsWUFBWSxLQUFLN0MseUdBQVVBLENBQUM2QztZQUN2RCxNQUFNRSxlQUFlM0MsbUJBQW1CbUMsS0FBS2xDLFdBQVc7WUFDeEQsTUFBTTJDLFVBQVVGLFlBQVlDO1lBRTVCLE1BQU1FLFVBQVVQLGlCQUFpQk0sV0FBV0YsWUFBWUg7WUFFeEQsSUFBSU0sU0FBUyxPQUFPO1FBQ3RCO1FBRUEsT0FBTztJQUNUO0lBRUEsT0FBT1I7QUFDVCxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYnJ1bm9sZWFsL0RvY3VtZW50cy9DdXJzb3MvTkVYVEpTL2JhcmJlYXJpYS9zcmMvY29tcG9uZW50cy9hcHBvaW50bWVudC1mb3JtL2NvbnN0YW50cy1hbmQtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SG91cnMsIGdldE1pbnV0ZXMsIGlzU2FtZURheSB9IGZyb20gXCJkYXRlLWZuc1wiO1xuaW1wb3J0IHsgQXBwb2ludG1lbnQgfSBmcm9tIFwiQC90eXBlcy9hcHBvaW50bWVudFwiO1xuXG5leHBvcnQgY29uc3QgU0VSVklDRV9PUFRJT05TID0gW1xuICBcIkJhcmJhIC0gUiQ4MCwwMFwiLFxuICBcIkJhcmJhICYgQ2FiZWxvXCIsXG4gIFwiQ2FiZWxvIG5hIHRlc291cmFcIixcbiAgXCJDYWJlbG8gbmEgbcOhcXVpbmFcIixcbl0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIFNlcnZpY2VPcHRpb24gPSAodHlwZW9mIFNFUlZJQ0VfT1BUSU9OUylbbnVtYmVyXTtcblxuLy8g4o+xIER1cmHDp8OjbyBkZSBjYWRhIHNlcnZpw6dvIChlbSBtaW51dG9zKVxuY29uc3QgU0VSVklDRV9EVVJBVElPTl9NQVA6IFJlY29yZDxTZXJ2aWNlT3B0aW9uLCBudW1iZXI+ID0ge1xuICBcIkJhcmJhXCI6IDMwLFxuICBcIkJhcmJhICYgQ2FiZWxvXCI6IDYwLFxuICBcIkNhYmVsbyBuYSB0ZXNvdXJhXCI6IDYwLFxuICBcIkNhYmVsbyBuYSBtw6FxdWluYVwiOiAzMCxcbn07XG5cbi8qKlxuICogRnVuw6fDo28gcm9idXN0YSBwYXJhIGRlc2NvYnJpciBhIGR1cmHDp8OjbyBkbyBzZXJ2acOnb1xuICogYSBwYXJ0aXIgZGEgZGVzY3Jpw6fDo28gc2FsdmEgbm8gYmFuY28uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZXJ2aWNlRHVyYXRpb24gPSAoZGVzY3JpcHRpb24/OiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICBpZiAoIWRlc2NyaXB0aW9uKSByZXR1cm4gMzA7XG5cbiAgY29uc3Qgbm9ybWFsaXplZCA9IGRlc2NyaXB0aW9uLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub3JtYWxpemVkLnN0YXJ0c1dpdGgoXCJiYXJiYSAmIGNhYmVsb1wiKSkgcmV0dXJuIDYwO1xuICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKFwiY2FiZWxvIG5hIHRlc291cmFcIikpIHJldHVybiA2MDtcbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aChcImJhcmJhIC0gciQ4MFwiKSkgcmV0dXJuIDMwO1xuICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKFwiY2FiZWxvIG5hIG3DoXF1aW5hXCIpKSByZXR1cm4gMzA7XG5cbiAgY29uc3Qga2V5ID0gZGVzY3JpcHRpb24gYXMgU2VydmljZU9wdGlvbjtcbiAgaWYgKGtleSBpbiBTRVJWSUNFX0RVUkFUSU9OX01BUCkge1xuICAgIHJldHVybiBTRVJWSUNFX0RVUkFUSU9OX01BUFtrZXldO1xuICB9XG5cbiAgcmV0dXJuIDMwO1xufTtcblxuY29uc3QgZ2VuZXJhdGVUaW1lT3B0aW9ucyA9ICgpOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IHRpbWVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGZvciAobGV0IGhvdXIgPSA5OyBob3VyIDw9IDIxOyBob3VyKyspIHtcbiAgICBmb3IgKGxldCBtaW51dGUgPSAwOyBtaW51dGUgPCA2MDsgbWludXRlICs9IDMwKSB7XG4gICAgICBpZiAoaG91ciA9PT0gMjEgJiYgbWludXRlID4gMCkgYnJlYWs7XG4gICAgICBjb25zdCB0aW1lU3RyaW5nID0gYCR7aG91clxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucGFkU3RhcnQoMiwgXCIwXCIpfToke21pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gO1xuICAgICAgdGltZXMucHVzaCh0aW1lU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGltZXM7XG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9PUFRJT05TID0gZ2VuZXJhdGVUaW1lT3B0aW9ucygpO1xuXG4vLyDwn5SNIENhbGN1bGEgaG9yw6FyaW9zIGRpc3BvbsOtdmVpcyBjb25zaWRlcmFuZG86XG4vLyAtIGRhdGEgc2VsZWNpb25hZGFcbi8vIC0gc2VydmnDp28gc2VsZWNpb25hZG8gKGR1cmHDp8Ojbylcbi8vIC0gYWdlbmRhbWVudG9zIGV4aXN0ZW50ZXMgKHNlbSBzb2JyZXBvcilcbi8vIC0gaG9yw6FyaW9zIHBhc3NhZG9zIG5vIGRpYSBkZSBob2plXG5leHBvcnQgY29uc3QgZ2V0QXZhaWxhYmxlVGltZXMgPSAocGFyYW1zOiB7XG4gIGRhdGU/OiBEYXRlIHwgbnVsbDtcbiAgc2VydmljZT86IFNlcnZpY2VPcHRpb24gfCB1bmRlZmluZWQ7XG4gIGFwcG9pbnRtZW50czogQXBwb2ludG1lbnRbXTtcbiAgY3VycmVudEFwcG9pbnRtZW50SWQ/OiBzdHJpbmc7XG59KTogc3RyaW5nW10gPT4ge1xuICBjb25zdCB7IGRhdGUsIHNlcnZpY2UsIGFwcG9pbnRtZW50cywgY3VycmVudEFwcG9pbnRtZW50SWQgfSA9IHBhcmFtcztcblxuICBpZiAoIWRhdGUgfHwgIXNlcnZpY2UpIHJldHVybiBbXTtcblxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIGNvbnN0IHNlbGVjdGVkRHVyYXRpb24gPSBnZXRTZXJ2aWNlRHVyYXRpb24oc2VydmljZSk7XG5cbiAgbGV0IGJhc2VUaW1lcyA9IFsuLi5USU1FX09QVElPTlNdO1xuXG4gIC8vIFNlIGZvciBob2plLCByZW1vdmUgaG9yw6FyaW9zIHF1ZSBqw6EgcGFzc2FyYW1cbiAgaWYgKGlzU2FtZURheShkYXRlLCBub3cpKSB7XG4gICAgY29uc3QgY3VycmVudE1pbnV0ZXMgPSBnZXRIb3Vycyhub3cpICogNjAgKyBnZXRNaW51dGVzKG5vdyk7XG5cbiAgICBiYXNlVGltZXMgPSBiYXNlVGltZXMuZmlsdGVyKCh0aW1lKSA9PiB7XG4gICAgICBjb25zdCBbaG91clN0ciwgbWludXRlU3RyXSA9IHRpbWUuc3BsaXQoXCI6XCIpO1xuICAgICAgY29uc3QgaG91ciA9IE51bWJlcihob3VyU3RyKTtcbiAgICAgIGNvbnN0IG1pbnV0ZSA9IE51bWJlcihtaW51dGVTdHIpO1xuICAgICAgY29uc3QgdGltZU1pbnV0ZXMgPSBob3VyICogNjAgKyBtaW51dGU7XG5cbiAgICAgIHJldHVybiB0aW1lTWludXRlcyA+IGN1cnJlbnRNaW51dGVzO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRmlsdHJhIGFnZW5kYW1lbnRvcyBzw7MgZGVzc2UgZGlhIChpbmRlcGVuZGVudGUgZG8gYmFyYmVpcm8pXG4gIGNvbnN0IGRheUFwcG9pbnRtZW50cyA9IGFwcG9pbnRtZW50cy5maWx0ZXIoKGFwcHQpID0+XG4gICAgaXNTYW1lRGF5KG5ldyBEYXRlKGFwcHQuc2NoZWR1bGVBdCksIGRhdGUpLFxuICApO1xuXG4gIC8vIFJlbW92ZSBob3LDoXJpb3MgcXVlIGNvbGlkZW0gY29tIHF1YWxxdWVyIGFnZW5kYW1lbnRvIGV4aXN0ZW50ZVxuICBjb25zdCBhdmFpbGFibGVUaW1lcyA9IGJhc2VUaW1lcy5maWx0ZXIoKHRpbWUpID0+IHtcbiAgICBjb25zdCBbaG91clN0ciwgbWludXRlU3RyXSA9IHRpbWUuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGhvdXIgPSBOdW1iZXIoaG91clN0cik7XG4gICAgY29uc3QgbWludXRlID0gTnVtYmVyKG1pbnV0ZVN0cik7XG4gICAgY29uc3QgY2FuZGlkYXRlU3RhcnQgPSBob3VyICogNjAgKyBtaW51dGU7XG4gICAgY29uc3QgY2FuZGlkYXRlRW5kID0gY2FuZGlkYXRlU3RhcnQgKyBzZWxlY3RlZER1cmF0aW9uO1xuXG4gICAgZm9yIChjb25zdCBhcHB0IG9mIGRheUFwcG9pbnRtZW50cykge1xuICAgICAgaWYgKGN1cnJlbnRBcHBvaW50bWVudElkICYmIGFwcHQuaWQgPT09IGN1cnJlbnRBcHBvaW50bWVudElkKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgYXBwdERhdGUgPSBuZXcgRGF0ZShhcHB0LnNjaGVkdWxlQXQpO1xuICAgICAgY29uc3QgYXBwdFN0YXJ0ID0gZ2V0SG91cnMoYXBwdERhdGUpICogNjAgKyBnZXRNaW51dGVzKGFwcHREYXRlKTtcbiAgICAgIGNvbnN0IGFwcHREdXJhdGlvbiA9IGdldFNlcnZpY2VEdXJhdGlvbihhcHB0LmRlc2NyaXB0aW9uKTtcbiAgICAgIGNvbnN0IGFwcHRFbmQgPSBhcHB0U3RhcnQgKyBhcHB0RHVyYXRpb247XG5cbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBjYW5kaWRhdGVTdGFydCA8IGFwcHRFbmQgJiYgYXBwdFN0YXJ0IDwgY2FuZGlkYXRlRW5kO1xuXG4gICAgICBpZiAob3ZlcmxhcCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gYXZhaWxhYmxlVGltZXM7XG59O1xuIl0sIm5hbWVzIjpbImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImlzU2FtZURheSIsIlNFUlZJQ0VfT1BUSU9OUyIsIlNFUlZJQ0VfRFVSQVRJT05fTUFQIiwiZ2V0U2VydmljZUR1cmF0aW9uIiwiZGVzY3JpcHRpb24iLCJub3JtYWxpemVkIiwidHJpbSIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsImtleSIsImdlbmVyYXRlVGltZU9wdGlvbnMiLCJ0aW1lcyIsImhvdXIiLCJtaW51dGUiLCJ0aW1lU3RyaW5nIiwidG9TdHJpbmciLCJwYWRTdGFydCIsInB1c2giLCJUSU1FX09QVElPTlMiLCJnZXRBdmFpbGFibGVUaW1lcyIsInBhcmFtcyIsImRhdGUiLCJzZXJ2aWNlIiwiYXBwb2ludG1lbnRzIiwiY3VycmVudEFwcG9pbnRtZW50SWQiLCJub3ciLCJEYXRlIiwic2VsZWN0ZWREdXJhdGlvbiIsImJhc2VUaW1lcyIsImN1cnJlbnRNaW51dGVzIiwiZmlsdGVyIiwidGltZSIsImhvdXJTdHIiLCJtaW51dGVTdHIiLCJzcGxpdCIsIk51bWJlciIsInRpbWVNaW51dGVzIiwiZGF5QXBwb2ludG1lbnRzIiwiYXBwdCIsInNjaGVkdWxlQXQiLCJhdmFpbGFibGVUaW1lcyIsImNhbmRpZGF0ZVN0YXJ0IiwiY2FuZGlkYXRlRW5kIiwiaWQiLCJhcHB0RGF0ZSIsImFwcHRTdGFydCIsImFwcHREdXJhdGlvbiIsImFwcHRFbmQiLCJvdmVybGFwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/appointment-form/constants-and-utils.ts\n',
        ),
      );

      /***/
    },
});
