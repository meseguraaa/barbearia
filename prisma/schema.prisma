// =======================
// GENERATOR & DATASOURCE
// =======================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============
// ENUMS
// ============

enum Role {
  CLIENT
  BARBER
  ADMIN
}

enum AppointmentStatus {
  PENDING
  DONE
  CANCELED
}

// Tipo de disponibilidade di√°ria do barbeiro
// DAY_OFF  = folga nesse dia espec√≠fico
// CUSTOM   = hor√°rios customizados s√≥ para esse dia (override do padr√£o semanal)
enum BarberDailyAvailabilityType {
  DAY_OFF
  CUSTOM
}

enum ExpenseCategory {
  RENT // Aluguel
  UTILITIES // Luz, √°gua, internet, etc
  TAXES // Impostos
  SUPPLIES // Suprimentos / compras
  OTHER // Outros
}

// ============
// MODELS
// ============

model User {
  id String @id @default(cuid())

  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?

  // üîπ Novo campo: telefone do usu√°rio (cliente/admin/barber)
  phone String?

  // Para barbeiro/admin: hash da senha (nunca em texto puro!)
  passwordHash String?

  role Role @default(CLIENT)

  // Relacionamentos
  appointmentsAsClient Appointment[] @relation("ClientAppointments")

  // rela√ß√£o com Barber (1-1 opcional)
  barber Barber?

  // rela√ß√µes com NextAuth
  accounts Account[]
  sessions Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// =======================
// NEXTAUTH MODELS
// =======================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// =======================
// DOM√çNIO DO SISTEMA
// =======================

model Barber {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  phone     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // üîó rela√ß√£o com User (opcional, para login de barbeiro)
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  // üîó rela√ß√£o com Appointment
  appointments Appointment[]

  // üîó disponibilidade padr√£o semanal
  weeklyAvailabilities BarberWeeklyAvailability[]

  // üîó exce√ß√µes de disponibilidade por dia
  dailyAvailabilities BarberDailyAvailability[]

  @@map("barbers")
}

model Service {
  id              String  @id @default(cuid())
  name            String
  price           Decimal @db.Decimal(10, 2)
  durationMinutes Int
  isActive        Boolean @default(true)

  /// Porcentagem de ganho do barbeiro nesse servi√ßo (%)
  barberPercentage Decimal @default(50.0) @db.Decimal(5, 2)

  /// Limite (em horas) antes do hor√°rio para cobrar taxa de cancelamento
  /// Ex: 2 = se cancelar com menos de 2h, pode aplicar taxa
  cancelLimitHours Int?

  /// Porcentagem da taxa de cancelamento sobre o valor do servi√ßo (%)
  cancelFeePercentage Decimal? @db.Decimal(5, 2)

  // Relacionamento com Appointment
  appointments Appointment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("services")
}

model Appointment {
  id          String   @id @default(cuid())
  description String
  clientName  String
  phone       String
  scheduleAt  DateTime

  status AppointmentStatus @default(PENDING)

  // Cliente que fez o agendamento (usu√°rio logado)
  clientId String
  client   User   @relation("ClientAppointments", fields: [clientId], references: [id])

  // Barbeiro que vai atender (pode ser nulo para dados antigos / ‚ÄúSem barbeiro‚Äù)
  barberId String?
  barber   Barber? @relation(fields: [barberId], references: [id])

  // Servi√ßo escolhido (pode ser nulo para agendamentos antigos)
  serviceId String?
  service   Service? @relation(fields: [serviceId], references: [id])

  /// Snapshot do valor do servi√ßo na √©poca do agendamento
  servicePriceAtTheTime Decimal? @db.Decimal(10, 2)

  /// Snapshot da porcentagem do barbeiro na √©poca do agendamento (%)
  barberPercentageAtTheTime Decimal? @db.Decimal(5, 2)

  /// Valor em dinheiro que o barbeiro ganha neste agendamento
  barberEarningValue Decimal? @db.Decimal(10, 2)

  /// Se uma taxa de cancelamento foi aplicada neste agendamento
  cancelFeeApplied Boolean @default(false)

  /// Valor em dinheiro da taxa de cancelamento aplicada
  cancelFeeValue Decimal? @db.Decimal(10, 2)

  /// Quem decidiu aplicar a taxa (ADMIN ou BARBER)
  cancelledByRole Role?

  /// Quem concluiu o atendimento (ADMIN ou BARBER)
  concludedByRole Role?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // √çndices √∫teis
  @@index([clientId])
  @@index([barberId])
  @@index([scheduleAt])
  @@index([serviceId])
  // Mant√©m o nome da tabela como "appointments"
  @@map("appointments")
}

model Product {
  id               String  @id @default(cuid())
  name             String
  imageUrl         String // foto obrigat√≥ria (URL)
  description      String
  price            Decimal // valor do produto (sem @db.Numeric)
  barberPercentage Int // porcentagem de comiss√£o do barbeiro (0-100)
  category         String // finalidade: "Barba", "Cabelo", etc
  isActive         Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Expense {
  id          String          @id @default(cuid())
  description String
  category    ExpenseCategory
  amount      Decimal         @db.Decimal(10, 2)
  dueDate     DateTime // data de vencimento (usada para saber o m√™s)
  isRecurring Boolean         @default(false) // se √© uma conta fixa m√™s a m√™s
  isPaid      Boolean         @default(false) // se j√° foi paga ou n√£o

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dueDate])
  @@map("expenses")
}

// =======================
// DISPONIBILIDADE DO BARBEIRO
// =======================

// Padr√£o semanal de disponibilidade do barbeiro
// Ex.: segunda, ter√ßa, etc, com intervalos de hor√°rio
model BarberWeeklyAvailability {
  id String @id @default(cuid())

  barberId String
  barber   Barber @relation(fields: [barberId], references: [id], onDelete: Cascade)

  /// 0 = domingo ... 6 = s√°bado
  weekday Int

  /// Se o barbeiro trabalha nesse dia da semana
  isActive Boolean @default(true)

  /// Intervalos de hor√°rio padr√£o nesse dia (ex.: 09:00‚Äì12:00, 13:00‚Äì18:00)
  intervals BarberWeeklyTimeInterval[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Um registro por barbeiro + dia da semana
  @@unique([barberId, weekday])
  @@map("barber_weekly_availabilities")
}

// Intervalos de hor√°rio para o padr√£o semanal
// Armazena "hora:minuto" como string (ex.: "09:00")
model BarberWeeklyTimeInterval {
  id String @id @default(cuid())

  weeklyAvailabilityId String
  weeklyAvailability   BarberWeeklyAvailability @relation(fields: [weeklyAvailabilityId], references: [id], onDelete: Cascade)

  startTime String // "HH:mm"
  endTime   String // "HH:mm"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("barber_weekly_time_intervals")
}

// Disponibilidade di√°ria espec√≠fica (exce√ß√µes)
// - DAY_OFF: folga nesse dia
// - CUSTOM: hor√°rios customizados s√≥ para este dia
model BarberDailyAvailability {
  id String @id @default(cuid())

  barberId String
  barber   Barber @relation(fields: [barberId], references: [id], onDelete: Cascade)

  /// Dia espec√≠fico (data inteira; voc√™ trata como "yyyy-MM-dd" na aplica√ß√£o)
  date DateTime

  type BarberDailyAvailabilityType

  intervals BarberDailyTimeInterval[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Um registro por barbeiro + dia espec√≠fico
  @@unique([barberId, date])
  @@map("barber_daily_availabilities")
}

// Intervalos de hor√°rio espec√≠ficos para um dia (quando type = CUSTOM)
model BarberDailyTimeInterval {
  id String @id @default(cuid())

  dailyAvailabilityId String
  dailyAvailability   BarberDailyAvailability @relation(fields: [dailyAvailabilityId], references: [id], onDelete: Cascade)

  startTime String // "HH:mm"
  endTime   String // "HH:mm"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("barber_daily_time_intervals")
}
